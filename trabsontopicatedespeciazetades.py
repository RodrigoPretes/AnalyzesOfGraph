# -*- coding: utf-8 -*-
"""TrabsonTopicatedEspeciazetades.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1XmYiFbcTPogrwxPbsQA6ih5XVHKvjlc_
"""

# Importando as bibliotecas necessárias

import networkx as nx
import matplotlib.pyplot as plt
import pandas as pd
import numpy as np

#Realizando a leitura do database
with open('facebook_combined.txt', 'r') as file:
    lines = file.readlines()
G = nx.Graph()
for line in lines:
    node1, node2 = map(int, line.strip().split())
    G.add_edge(node1, node2)

#Lendo a distribuição do degree
degree_distribution = list(dict(G.degree()).values())

# Numeros de nos e arestas
num_nodes = G.number_of_nodes()
num_edges = G.number_of_edges()

# Grau medio
grau_medio = sum(dict(G.degree()).values()) / num_nodes


print(f"Quantidade de nos: {num_nodes}")
print(f"Quantidade de arestas: {num_edges}")
print(f"Grau Medio: {grau_medio:.2f}")

#Densidade do grafo
density = nx.density(G)
print(f"Densidade do grafo: {density:.4f}")

#Sequencia de nos com maior numero de grau
sequencia_grau = sorted([d for n, d in G.degree()], reverse=True)
print("Sequencia de grau:", sequencia_grau)

#Aumentando o tamanho da figura usando matplotlib
plt.figure(figsize=(12,10))
#criando o layout da rede
spring_pos = nx.spring_layout(G)
#desenhando a rede
nx.draw(G, node_size=20, pos = spring_pos, node_color = 'red')

#Detectando possiveis comunidades graças ao agrupamento gerado pelo grafo

!pip install python-louvain

#importando nosso algoritmo de detecção de comunidades
from community import community_louvain

#computar os grupos
partitions = community_louvain.best_partition(G)

#Transformando os valores em lista
values = list(partitions.values())

#Definindo o tamanho da imagem
plt.figure(figsize=(12,10))
plt.axis("off")

#Mostrando as diferentes comunidades identificadas separada por cor

nx.draw_networkx(G, pos = spring_pos, cmap=plt.get_cmap("jet"),
                  node_color=values, node_size = 35, with_labels = False)

#Separando uma comunidade atraves do algoritmo
#Listando o numero de comunidades
list(set(values))

#Separando uma comunidade e mostrando a rede de relações
#Nesse caso separei a comunidade 0

cluster_id = 0


cluster = [node for node in G.nodes() if partitions[node] == cluster_id]

# criando um subgrafo passando os nos selecionados
cluster = G.subgraph(cluster)

plt.figure(figsize=(12,10))

nx.draw_networkx(cluster , node_color='red',
                 node_size=70, with_labels=False)

#Separando uma comunidade e mostrando a rede de relações
#Nesse caso separei a comunidade 1

cluster_id = 1


cluster = [node for node in G.nodes() if partitions[node] == cluster_id]


#Criando um subgrafo passando os nos selecionados
cluster = G.subgraph(cluster)

plt.figure(figsize=(12,10))

nx.draw_networkx(cluster , node_color='blue',
                 node_size=70, with_labels=False)

#Conclusões Finais:


# Pegando como exemplo qualquer uma das comunidades que podem ser mostradas (0 - 15),
# Poderiamos criar um fluxo de informação de caracteristicas somente a essa comunidade que possuem caracteristicas em comum
# Seja: compras, pontos de interesses: politica, economia, esportes.

# Graças a uma simples analise de um grafo fornecido pela conectividade entre usuarios da rede facebook.



#Considerações:

#Tentei executar diferentes formas de layout no grafo que escolhi do facebook, contudo aparentemente por ser um grafo muito grande ele fica de maneira borrada
#Ou seja, os nós permanecem muito unidos.